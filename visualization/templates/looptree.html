<!-- A visualizer for looping trees of hardware space vs compute time using D3-->
{% extends "base.html" %}
{% block head %}
    <script src="https://d3js.org/d3.v4.min.js"></script>
{% endblock %}
{# Titles the page to something recognizable #}
{% block title %} LoopTree {% endblock %}
{% block body %}
<div class="cell medium-8 grid-x">
    <h1 class="cell small-12">Mapping of Type: {{ mapping_type }}</h1>
    <br/>
    <div id="looptree" class="cell small-12"></div>
    <br/>
    <div id="tree-compute" class="cell small-12"></div>
</div>
{% endblock %}

{% block epilogue %}
<script src="https://d3js.org/d3.v7.min.js"></script>
<script type="text/javascript">
/**
 * Converts a mapping to a hierarchy structure. All arrays are converted so that
 * each subsequent element in the array is a child of the previous element.
 * If there is branching, all branches are siblings and are children of the
 * element they branched off of.
 *
 * @param {Object} mapping  The JSON containing the mapping in the default YAML
 *                          format. Only contains the portion corresponding to
 *                          children of the root we're appending to.
 * @param {Object} root     The root we're currently building off of.
 */
function mapping_to_hierarchy(mapping, root) {
    // If the mapping segment is an array, make them all children of each other.
    if (mapping instanceof Array) {
        // Makes the dependency tree.
        for (const ref of mapping) {
            // Initializes child with no dependencies.
            const child = {
                "dependencies": []
            };
            /* Copies all keys in the reference if it's not leading to other
             * nodes */
             for (key in ref) {
                // If the key is not branches, copy it over.
                if (key !== "branches") {
                    child[key] = ref[key];
                // If it's leading to other nodes, recurse.
                } else {
                    // Goes through every branch and copies.
                    for (branch of ref[key]) {
                        mapping_to_hierarchy(branch, child);
                    }
                }
            }
            // Adds the child to the root.
            root["dependencies"].push(child);

            // Sets root as the child as this is a sequential process.
            root = child;
        }
    }
}

/**
 * Generates a tree diagram of the mapping.
 *
 * @param {Object} mapping  The JSON containing the mapping in a D3 hierarchy.
 *
 * @return {Object} The D3 tree diagram as an SVG.
 */
function diagram(mapping) {
    // Set the dimensions and margins of the diagram.
    const width = 1000;
    const height = 1000;
    const margin = 50;

    // Creates the SVG object.
    const svg = d3.create("svg")
                    .attr("width", width)
                    .attr("height",height);
    // Creates a bounding box inside the SVG for margin purposes.
    const g = svg.append("g")
                    .attr("transform", `translate(${margin}, ${margin})`);

    // Creates a tree layout calculator and assigns the size.
    const treemap = d3.tree()
        .size([width - 2 * margin, height - 2 * margin]);

    // Assigns parent, children, height, depth.
    const root = d3.hierarchy(mapping, d => d.dependencies);

    // Assigns the x and y position for the nodes.
    const treeData = treemap(root);

    // Creates generic for all links.
    const links = g.selectAll(".link");

    // Assigns data to link generics and generates the path.
    let linkGraphics = links
        .data(treeData.descendants().slice(1))
        .enter()
        .append("path")
            .attr("class", "link")
            .attr("d", d => {
                return `M ${d.x} ${d.y}
                        C ${d.x} ${(d.y + d.parent.y) / 2},
                        ${d.x} ${(d.y + d.parent.y) / 2},
                        ${d.parent.x} ${d.parent.y}`;
            })
            .style("fill", "none")
            .attr("stroke", "#ccc");


    // Creates generic for all links.
    const nodes = g.selectAll(".node");

    // Assigns data to node generics and creates a graphics container for all nodes.
    let nodeGraphics = nodes
        .data(treeData.descendants())
        .enter()
        .append("g")
            .attr("class", d => {
                return `node${d.children ? " node--internal" : " node--leaf"}`;
            })
            .attr("transform", d => `translate(${d.x}, ${d.y})`);

    // Adds the white text background to the node.
    nodeGraphics.append("text")
            .style("text-anchor", "middle")
            .style("z-index", 99)
            .style("stroke", "white")
            .style("stroke-width", "0.5em")
            .text(d => d.data.type);
    // Adds the text to the node.
    nodeGraphics.append("text") 
            .style("text-anchor", "middle")
            .style("z-index", 100)
            .text(d => d.data.type);
    
    // Updates the SVG on click such that the node clicked hides its children.
    function update(event, source) {
        // If the node is a leaf, do nothing.
        if (source.children === undefined) {
            return;
        }

        // If the node is expanded, hide its children.
        if (source.children) {
            source._children = source.children;
            source.children = null;
        }
        // If the node is collapsed, reveal its children.
        else {
            source.children = source._children;
            source._children = null;
        }

        // Removes the old graphics.
        nodeGraphics.remove();
        linkGraphics.remove();

        // Recalculate positions in the tree.
        const newTreeData = treemap(root);

        // Generates the new the graphics.
        nodeGraphics = nodes
                .data(newTreeData.descendants())
                .enter()
                .append("g")
                    .attr("class", d => {
                        return `node${d.children ? " node--internal" : " node--leaf"}`;
                    })
                    .attr("transform", d => `translate(${d.x}, ${d.y})`);

        // Adds the white text background to the node.
        nodeGraphics.append("text")
                .style("text-anchor", "middle")
                .style("z-index", 99)
                .style("stroke", "white")
                .style("stroke-width", "0.5em")
                .text(d => d.data.type);
        // Adds the text to the node.
        nodeGraphics.append("text") 
                .style("text-anchor", "middle")
                .style("z-index", 100)
                .text(d => d.data.type);
        
        linkGraphics = links
                    .data(newTreeData.descendants().slice(1))
                    .enter()
                    .append("path")
                        .attr("class", "link")
                        .attr("d", d => {
                            return `M ${d.x} ${d.y}
                                    C ${d.x} ${(d.y + d.parent.y) / 2},
                                    ${d.x} ${(d.y + d.parent.y) / 2},
                                    ${d.parent.x} ${d.parent.y}`;
                        })
                        .style("fill", "none")
                        .attr("stroke", "#ccc");
        

        nodeGraphics.on("click", update);

        document.getElementById("looptree").innerHTML = svg.node().outerHTML;
        
        console.log('click');
    };

    // Adds the click event to the nodes.
    nodeGraphics.on("click", update);

    return svg;
}

/** 
* Starts generating the looptree visualization graphic once all the dependencies
* have been loaded.*/
function main() {
    // Interprets the map_tree Python dictionary as a JSON object.
    let map_tree = {{ map_tree|tojson }};

    // Converts the map tree into a D3 parseable hierarchy structure.
    let hierarchy = {
        "dependencies": [],
        "type": {{ mapping_type|tojson }},
    };
    mapping_to_hierarchy(map_tree, hierarchy);

    // Generates the diagram.
    let visual = diagram(hierarchy);
    console.log(visual);
    document.getElementById("looptree").append(visual.node());
}

window.onload = main();
</script>
{% endblock %}